name: DB Restore from R2 (Supabase)

on:
  workflow_dispatch:
    inputs:
      target:
        description: "Qual banco restaurar?"
        type: choice
        required: true
        default: dev
        options:
          - dev
          - verify
          - prod
      r2_key:
        description: "Chave completa no R2 (ex.: revo/prod/2026/01/15/supabase_prod_YYYYMMDD_HHMMSS.dump.gz)"
        type: string
        required: true
      confirm:
        description: "Para PROD, digite RESTORE_PROD"
        type: string
        required: false

permissions:
  contents: read
  issues: write

concurrency:
  group: db-restore-from-r2
  cancel-in-progress: false

jobs:
  restore:
    runs-on: ubuntu-latest
    timeout-minutes: 40
    env:
      TARGET: ${{ inputs.target }}
      R2_KEY: ${{ inputs.r2_key }}
      CONFIRM: ${{ inputs.confirm }}
      R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
      # Fallback para o bucket padrão sugerido, caso a secret não exista.
      R2_BUCKET: ${{ secrets.R2_BUCKET || 'revo-erp-backups-prod' }}
      AWS_REGION: auto
      AWS_DEFAULT_REGION: auto
      AWS_EC2_METADATA_DISABLED: "true"
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      DEV_URL: ${{ secrets.SUPABASE_DB_URL_DEV }}
      PROD_URL: ${{ secrets.SUPABASE_DB_URL_PROD }}
      VERIFY_URL: ${{ secrets.SUPABASE_DB_URL_VERIFY }}
    steps:
      - name: Safety checks
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${R2_ENDPOINT:-}" || -z "${R2_BUCKET:-}" || -z "${AWS_ACCESS_KEY_ID:-}" || -z "${AWS_SECRET_ACCESS_KEY:-}" ]]; then
            echo "::error::Missing R2 secrets."
            exit 1
          fi
          if [[ -z "${TARGET:-}" ]]; then
            echo "::error::Missing target."
            exit 1
          fi
          if [[ -z "${R2_KEY:-}" ]]; then
            echo "::error::Missing r2_key."
            exit 1
          fi
          if [[ "${TARGET}" == "prod" && "${CONFIRM:-}" != "RESTORE_PROD" ]]; then
            echo "::error::Para restaurar PROD, informe confirm=RESTORE_PROD."
            exit 1
          fi

      - name: Resolve target DB URL
        id: db
        shell: bash
        run: |
          set -euo pipefail
          case "${TARGET}" in
            dev) url="${DEV_URL}" ;;
            prod) url="${PROD_URL}" ;;
            verify) url="${VERIFY_URL}" ;;
            *) echo "::error::Target inválido: ${TARGET}"; exit 1 ;;
          esac
          if [[ -z "${url:-}" ]]; then
            echo "::error::DB URL secret ausente para target=${TARGET}"
            exit 1
          fi
          echo "url=$url" >> "$GITHUB_OUTPUT"

      - name: Install awscli
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y python3-pip
          python3 -m pip install --upgrade pip
          python3 -m pip install --upgrade awscli

      - name: Download dump from R2
        shell: bash
        run: |
          set -euo pipefail
          file="$(basename "${R2_KEY}")"
          echo "Baixando s3://${R2_BUCKET}/${R2_KEY}"
          aws --region auto --endpoint-url "${R2_ENDPOINT}" s3 cp "s3://${R2_BUCKET}/${R2_KEY}" "$file" --only-show-errors
          ls -lh "$file"
          gunzip -c "$file" > "${file%.gz}"
          ls -lh "${file%.gz}"

      - name: Restore into target DB (pg_restore)
        shell: bash
        env:
          DATABASE_URL: ${{ steps.db.outputs.url }}
        run: |
          set -euo pipefail
          dump="$(basename "${R2_KEY%.gz}")"
          echo "Restaurando ${dump} em ${TARGET}..."
          docker run --rm \
            -v "$PWD:/work" \
            -w /work \
            postgres:17 \
            pg_restore \
              --clean --if-exists \
              --no-owner --no-privileges \
              -d "${DATABASE_URL}" \
              "$dump"

      - name: Update backup catalog (status=restored)
        if: always()
        shell: bash
        env:
          DATABASE_URL: ${{ steps.db.outputs.url }}
        run: |
          set -euo pipefail
          status="restored"
          if [[ "${{ job.status }}" != "success" ]]; then status="failed"; fi

          docker run --rm postgres:17 \
            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X -qAt -c "
              update public.ops_db_backups
                 set status='${status}',
                     meta = jsonb_set(coalesce(meta,'{}'::jsonb), '{last_restore}', jsonb_build_object(
                       'at', now(),
                       'run', '${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}',
                       'target', '${TARGET}'
                     ), true)
               where r2_key = '${R2_KEY}';
            " || true

      - name: Upsert issue on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const title = "OPS ALERT: Restore de backup falhou";
            const labels = ["ops-alert", "backup"];
            const body = [
              "Falha ao restaurar backup do R2 para o banco alvo.",
              "",
              `- target: ${process.env.TARGET}`,
              `- r2_key: ${process.env.R2_KEY}`,
              `- run: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              "",
              "Ação recomendada:",
              "- Verificar integridade do dump/manifest no R2.",
              "- Validar permissões/extensões e compatibilidade de versão.",
            ].join("\n");

            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: "open",
              labels: labels.join(","),
              per_page: 100,
            });
            const existing = issues.find(i => i.title === title);
            if (existing) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body,
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels,
              });
            }
