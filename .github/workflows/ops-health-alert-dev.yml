name: OPS health alert (DEV)

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch:

permissions:
  contents: read
  issues: write

concurrency:
  group: ops-health-alert-dev
  cancel-in-progress: false

jobs:
  ops-health:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      THRESHOLD_DLQ: "0"
      THRESHOLD_FAILED: "0"
      THRESHOLD_PENDING: "200"
      THRESHOLD_RPC_P95_MS: "2000"
      THRESHOLD_RPC_ERROR_RATE_PCT: "1"
      THRESHOLD_RPC_MIN_SAMPLES: "30"
      THRESHOLD_403_MISSING_ACTIVE_15M: "0"
      THRESHOLD_403_RECOVERY_FAILED_15M: "0"
    steps:
      - name: Install psql + jq
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client jq

      - name: Collect queue health from DEV
        id: health
        env:
          DATABASE_URL: ${{ secrets.SUPABASE_DB_URL_DEV }}
        run: |
          set -euo pipefail

          if [[ -z "${DATABASE_URL:-}" ]]; then
            echo "Missing secret SUPABASE_DB_URL_DEV" >&2
            exit 1
          fi

          HEALTH_JSON="$(psql "$DATABASE_URL" -Atc "
            select jsonb_build_object(
              'nfe_pending',
                case when to_regclass('public.fiscal_nfe_webhook_events') is null then 0 else (
                  select count(*)::int
                  from public.fiscal_nfe_webhook_events
                  where processed_at is null
                    and (next_retry_at is null or next_retry_at <= now())
                    and (locked_at is null or locked_at < (now() - interval '10 minutes'))
                ) end,
              'nfe_failed',
                case when to_regclass('public.fiscal_nfe_webhook_events') is null then 0 else (
                  select count(*)::int
                  from public.fiscal_nfe_webhook_events
                  where processed_at is null
                    and last_error is not null
                ) end,
              'nfe_locked',
                case when to_regclass('public.fiscal_nfe_webhook_events') is null then 0 else (
                  select count(*)::int
                  from public.fiscal_nfe_webhook_events
                  where processed_at is null
                    and locked_at is not null
                    and locked_at >= (now() - interval '10 minutes')
                ) end,

              'ecommerce_pending',
                case when to_regclass('public.ecommerce_jobs') is null then 0 else (
                  select count(*)::int
                  from public.ecommerce_jobs
                  where status in ('pending','processing')
                    and (next_retry_at is null or next_retry_at <= now())
                    and (scheduled_for is null or scheduled_for <= now())
                    and (locked_at is null or locked_at < (now() - interval '10 minutes'))
                ) end,
              'ecommerce_failed',
                case when to_regclass('public.ecommerce_jobs') is null then 0 else (
                  select count(*)::int
                  from public.ecommerce_jobs
                  where status = 'error'
                    and last_error is not null
                ) end,
              'ecommerce_dlq',
                case when to_regclass('public.ecommerce_job_dead_letters') is null then 0 else (
                  select count(*)::int
                  from public.ecommerce_job_dead_letters
                ) end,

              'finance_pending',
                case when to_regclass('public.finance_jobs') is null then 0 else (
                  select count(*)::int
                  from public.finance_jobs
                  where status in ('pending','processing')
                    and (next_retry_at is null or next_retry_at <= now())
                    and (locked_at is null or locked_at < (now() - interval '10 minutes'))
                ) end,
              'finance_failed',
                case when to_regclass('public.finance_jobs') is null then 0 else (
                  select count(*)::int
                  from public.finance_jobs
                  where status = 'failed'
                    and last_error is not null
                ) end,
              'finance_dlq',
                case when to_regclass('public.finance_job_dead_letters') is null then 0 else (
                  select count(*)::int
                  from public.finance_job_dead_letters
                ) end,

              'rpc_count_15m',
                case when to_regclass('public.app_logs') is null then 0 else (
                  select count(*)::int
                  from public.app_logs
                  where created_at >= (now() - interval '15 minutes')
                    and event = 'metric.rpc'
                ) end,
              'rpc_error_rate_pct_15m',
                case when to_regclass('public.app_logs') is null then 0 else (
                  select round(100.0 * (
                    select count(*)::numeric
                    from public.app_logs
                    where created_at >= (now() - interval '15 minutes')
                      and event = 'metric.rpc'
                      and (message like '%\"ok\":false%' or message like '%\"status\":4%' or message like '%\"status\":5%')
                  ) / greatest(1, (
                    select count(*)::numeric
                    from public.app_logs
                    where created_at >= (now() - interval '15 minutes')
                      and event = 'metric.rpc'
                  )), 2)
                ) end,
              'rpc_p95_ms_15m',
                case when to_regclass('public.app_logs') is null then 0 else (
                  select coalesce(
                    (
                      select percentile_cont(0.95) within group (order by (message::jsonb->>'duration_ms')::numeric)
                      from public.app_logs
                      where created_at >= (now() - interval '15 minutes')
                        and event = 'metric.rpc'
                        and (message::jsonb ? 'duration_ms')
                    ),
                    0
                  )::numeric
                ) end,

              'ops_403_total_15m',
                case when to_regclass('public.ops_403_events') is null then 0 else (
                  select count(*)::int
                  from public.ops_403_events
                  where created_at >= (now() - interval '15 minutes')
                ) end,
              'ops_403_missing_active_empresa_15m',
                case when to_regclass('public.ops_403_events') is null then 0 else (
                  select count(*)::int
                  from public.ops_403_events
                  where created_at >= (now() - interval '15 minutes')
                    and kind = 'missing_active_empresa'
                ) end,
              'ops_403_recovery_failed_15m',
                case when to_regclass('public.ops_403_events') is null then 0 else (
                  select count(*)::int
                  from public.ops_403_events
                  where created_at >= (now() - interval '15 minutes')
                    and recovery_attempted is true
                    and coalesce(recovery_ok, false) is false
                ) end
            )::text
          ")"

          echo "health_json=$HEALTH_JSON" >> "$GITHUB_OUTPUT"

          pending_max="$(echo "$HEALTH_JSON" | jq -r '[.nfe_pending,.ecommerce_pending,.finance_pending] | max')"
          failed_sum="$(echo "$HEALTH_JSON" | jq -r '.nfe_failed + .ecommerce_failed + .finance_failed')"
          dlq_sum="$(echo "$HEALTH_JSON" | jq -r '.ecommerce_dlq + .finance_dlq')"
          rpc_count_15m="$(echo "$HEALTH_JSON" | jq -r '.rpc_count_15m')"
          rpc_error_rate_pct_15m="$(echo "$HEALTH_JSON" | jq -r '.rpc_error_rate_pct_15m')"
          rpc_p95_ms_15m="$(echo "$HEALTH_JSON" | jq -r '.rpc_p95_ms_15m')"
          ops_403_total_15m="$(echo "$HEALTH_JSON" | jq -r '.ops_403_total_15m')"
          ops_403_missing_active_empresa_15m="$(echo "$HEALTH_JSON" | jq -r '.ops_403_missing_active_empresa_15m')"
          ops_403_recovery_failed_15m="$(echo "$HEALTH_JSON" | jq -r '.ops_403_recovery_failed_15m')"

          echo "pending_max=$pending_max" >> "$GITHUB_OUTPUT"
          echo "failed_sum=$failed_sum" >> "$GITHUB_OUTPUT"
          echo "dlq_sum=$dlq_sum" >> "$GITHUB_OUTPUT"
          echo "rpc_count_15m=$rpc_count_15m" >> "$GITHUB_OUTPUT"
          echo "rpc_error_rate_pct_15m=$rpc_error_rate_pct_15m" >> "$GITHUB_OUTPUT"
          echo "rpc_p95_ms_15m=$rpc_p95_ms_15m" >> "$GITHUB_OUTPUT"
          echo "ops_403_total_15m=$ops_403_total_15m" >> "$GITHUB_OUTPUT"
          echo "ops_403_missing_active_empresa_15m=$ops_403_missing_active_empresa_15m" >> "$GITHUB_OUTPUT"
          echo "ops_403_recovery_failed_15m=$ops_403_recovery_failed_15m" >> "$GITHUB_OUTPUT"

          alert_queues="false"
          alert_403="false"

          if [[ "$dlq_sum" -gt "${THRESHOLD_DLQ}" ]]; then alert_queues="true"; fi
          if [[ "$failed_sum" -gt "${THRESHOLD_FAILED}" ]]; then alert_queues="true"; fi
          if [[ "$pending_max" -gt "${THRESHOLD_PENDING}" ]]; then alert_queues="true"; fi
          if [[ "$rpc_count_15m" -ge "${THRESHOLD_RPC_MIN_SAMPLES}" ]]; then
            rpc_p95_int="${rpc_p95_ms_15m%.*}"
            rpc_err_int="${rpc_error_rate_pct_15m%.*}"
            if [[ "$rpc_p95_int" -gt "${THRESHOLD_RPC_P95_MS}" ]]; then alert_queues="true"; fi
            if [[ "$rpc_err_int" -gt "${THRESHOLD_RPC_ERROR_RATE_PCT}" ]]; then alert_queues="true"; fi
          fi
          if [[ "$ops_403_missing_active_empresa_15m" -gt "${THRESHOLD_403_MISSING_ACTIVE_15M}" ]]; then alert_403="true"; fi
          if [[ "$ops_403_recovery_failed_15m" -gt "${THRESHOLD_403_RECOVERY_FAILED_15M}" ]]; then alert_403="true"; fi

          alert_any="false"
          if [[ "$alert_queues" == "true" || "$alert_403" == "true" ]]; then alert_any="true"; fi

          echo "alert_queues=$alert_queues" >> "$GITHUB_OUTPUT"
          echo "alert_403=$alert_403" >> "$GITHUB_OUTPUT"
          echo "alert=$alert_any" >> "$GITHUB_OUTPUT"

      - name: Upsert ops alert issue — queues/DLQ (DEV) (when alert_queues=true)
        if: steps.health.outputs.alert_queues == 'true'
        uses: actions/github-script@v7
        env:
          HEALTH_JSON: ${{ steps.health.outputs.health_json }}
          PENDING_MAX: ${{ steps.health.outputs.pending_max }}
          FAILED_SUM: ${{ steps.health.outputs.failed_sum }}
          DLQ_SUM: ${{ steps.health.outputs.dlq_sum }}
          RPC_COUNT_15M: ${{ steps.health.outputs.rpc_count_15m }}
          RPC_ERR_15M: ${{ steps.health.outputs.rpc_error_rate_pct_15m }}
          RPC_P95_15M: ${{ steps.health.outputs.rpc_p95_ms_15m }}
        with:
          script: |
            const title = "OPS ALERT (DEV): filas/DLQ acima do limite";
            const labels = ["ops-alert","env:dev"];
            const body = [
              "Detectado possível problema operacional em DEV (filas/DLQ).",
              "",
              `- pending_max: ${process.env.PENDING_MAX}`,
              `- failed_sum: ${process.env.FAILED_SUM}`,
              `- dlq_sum: ${process.env.DLQ_SUM}`,
              `- rpc_count_15m: ${process.env.RPC_COUNT_15M}`,
              `- rpc_error_rate_pct_15m: ${process.env.RPC_ERR_15M}`,
              `- rpc_p95_ms_15m: ${process.env.RPC_P95_15M}`,
              "",
              "Detalhes (JSON):",
              "```json",
              String(process.env.HEALTH_JSON ?? "{}"),
              "```",
              "",
              `Run: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              "",
              "Próximos passos sugeridos:",
              "- Verificar se a base DEV está íntegra (migrations/verify).",
              "- Verificar workers e logs.",
            ].join("\n");

            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: "open",
              labels: labels.join(","),
              per_page: 100,
            });
            const existing = issues.find(i => i.title === title);
            if (existing) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body,
              });
              return;
            }
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body,
              labels,
            });

      - name: Upsert ops alert issue — 403 intermitente (DEV) (when alert_403=true)
        if: steps.health.outputs.alert_403 == 'true'
        uses: actions/github-script@v7
        env:
          HEALTH_JSON: ${{ steps.health.outputs.health_json }}
          OPS_403_TOTAL_15M: ${{ steps.health.outputs.ops_403_total_15m }}
          OPS_403_MISSING_ACTIVE_15M: ${{ steps.health.outputs.ops_403_missing_active_empresa_15m }}
          OPS_403_RECOVERY_FAILED_15M: ${{ steps.health.outputs.ops_403_recovery_failed_15m }}
        with:
          script: |
            const title = "OPS ALERT (DEV): 403 intermitente (empresa ativa/recovery)";
            const labels = ["ops-alert","env:dev","ops-403"];
            const body = [
              "Detectado 403 intermitente em DEV (empresa ativa/recovery).",
              "",
              `- ops_403_total_15m: ${process.env.OPS_403_TOTAL_15M}`,
              `- ops_403_missing_active_empresa_15m: ${process.env.OPS_403_MISSING_ACTIVE_15M}`,
              `- ops_403_recovery_failed_15m: ${process.env.OPS_403_RECOVERY_FAILED_15M}`,
              "",
              "Detalhes (JSON):",
              "```json",
              String(process.env.HEALTH_JSON ?? "{}"),
              "```",
              "",
              `Run: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              "",
              "Próximos passos sugeridos:",
              "- Priorizar `kind=missing_active_empresa` e `recovery_ok=false`.",
              "- Validar se o app está evitando fetch antes de `activeEmpresaId`.",
              "- Rodar E2E `boot-no-403` e `console-sweep`.",
            ].join("\n");

            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: "open",
              labels: labels.join(","),
              per_page: 100,
            });
            const existing = issues.find(i => i.title === title);
            if (existing) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body,
              });
              return;
            }
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body,
              labels,
            });

