name: supabase-migrations-main

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  apply-baseline-verify:
    name: Apply BASELINE to VERIFY (prelude + audit bootstrap)
    runs-on: ubuntu-latest
    env:
      SUPABASE_DB_URL_VERIFY: ${{ secrets.SUPABASE_DB_URL_VERIFY }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install PostgreSQL client
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      # PRELUDE: dropar enums conflitantes já existentes no VERIFY (idempotente)
      - name: [VERIFY] Prelude - drop conflicting enums (idempotent)
        run: |
          set -euo pipefail
          echo "[VERIFY][PRELUDE] Dropping pre-existing enums if any..."
          psql "$SUPABASE_DB_URL_VERIFY" -v ON_ERROR_STOP=1 <<'SQL'
          SET search_path = pg_catalog, public;

          DO $$
          DECLARE t text;
          BEGIN
            FOREACH t IN ARRAY ARRAY[
              'billing_cycle',
              'contribuinte_icms_enum'
              -- se surgir outro "type <X> already exists", incluir aqui: 'outro_enum',
            ]
            LOOP
              IF EXISTS (
                SELECT 1 FROM pg_type ty
                WHERE ty.typname = t
                  AND ty.typtype = 'e'
                  AND ty.typnamespace = 'public'::regnamespace
              ) THEN
                EXECUTE format('DROP TYPE %I.%I CASCADE;', 'public', t);
                RAISE NOTICE 'Dropped pre-existing type: public.%', t;
              END IF;
            END LOOP;
          END$$;
          SQL
          echo "[VERIFY][PRELUDE] OK"

      # STUBS: funções usadas em DEFAULTs antes da baseline (idempotente)
      - name: [VERIFY] Create context function stubs (idempotent)
        run: |
          set -euo pipefail
          echo "[VERIFY][STUBS] Creating stubs for context functions..."
          psql "$SUPABASE_DB_URL_VERIFY" -v ON_ERROR_STOP=1 <<'SQL'
          SET search_path = pg_catalog, public;

          CREATE OR REPLACE FUNCTION public.current_user_id()
          RETURNS uuid
          LANGUAGE sql
          STABLE
          SET search_path = pg_catalog, public
          AS $$
            SELECT
              COALESCE(
                NULLIF(current_setting('request.jwt.claim.sub', true), '')::uuid,
                NULLIF( (current_setting('request.jwt.claims', true))::jsonb ->> 'sub', '' )::uuid
              )
          $$;

          CREATE OR REPLACE FUNCTION public.current_empresa_id()
          RETURNS uuid
          LANGUAGE sql
          STABLE
          SET search_path = pg_catalog, public
          AS $$
            SELECT
              COALESCE(
                NULLIF(current_setting('app.current_empresa_id', true), '')::uuid,
                NULLIF( (current_setting('request.jwt.claims', true))::jsonb ->> 'empresa_id', '' )::uuid
              )
          $$;
          SQL
          echo "[VERIFY][STUBS] OK"

      # BOOTSTRAP: garantir schema audit mínimo exigido pela baseline (idempotente)
      - name: [VERIFY] Bootstrap AUDIT schema (idempotent)
        run: |
          set -euo pipefail
          echo "[VERIFY][AUDIT] Ensuring audit schema/table exist..."
          psql "$SUPABASE_DB_URL_VERIFY" -v ON_ERROR_STOP=1 <<'SQL'
          SET search_path = pg_catalog, public;

          DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_namespace WHERE nspname = 'audit') THEN
              EXECUTE 'CREATE SCHEMA audit';
            END IF;
          END $$;

          CREATE TABLE IF NOT EXISTS audit.events (
            occurred_at timestamptz NOT NULL DEFAULT now(),
            source      text,
            table_name  text,
            op          text,
            pk          jsonb,
            row_old     jsonb,
            row_new     jsonb,
            diff        jsonb,
            meta        jsonb
          );

          DO $$
          BEGIN
            IF NOT EXISTS (
              SELECT 1 FROM pg_indexes
              WHERE schemaname='audit' AND indexname='events__occurred_at_desc'
            ) THEN
              EXECUTE 'CREATE INDEX events__occurred_at_desc ON audit.events (occurred_at DESC)';
            END IF;
          END $$;
          SQL
          echo "[VERIFY][AUDIT] OK"

      # APLICAÇÃO DA BASELINE
      - name: [VERIFY] Apply BASELINE via psql
        shell: bash
        run: |
          set -euo pipefail
          echo "[MIGRATE][VERIFY] Locating baseline in supabase/migrations..."
          BASELINE="$(ls -1 supabase/migrations/*_baseline.sql | head -n 1)"
          if [ -z "$BASELINE" ]; then
            echo "::error::No *_baseline.sql found in supabase/migrations"
            exit 1
          fi
          echo "[MIGRATE][VERIFY] BASELINE => ${BASELINE}"
          psql "$SUPABASE_DB_URL_VERIFY" -v ON_ERROR_STOP=1 -f "$BASELINE"
          echo "[MIGRATE][VERIFY] Baseline applied successfully."

  migrate-sync-history:
    name: Sync migration history (VERIFY → PROD)
    runs-on: ubuntu-latest
    needs: apply-baseline-verify
    environment:
      name: production
    env:
      SUPABASE_DB_URL_VERIFY: ${{ secrets.SUPABASE_DB_URL_VERIFY }}
      SUPABASE_DB_URL_PROD:   ${{ secrets.SUPABASE_DB_URL_PROD }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: supabase db push (VERIFY)
        run: |
          set -euo pipefail
          echo "[MIGRATE][VERIFY] Running supabase db push on VERIFY to align migration history..."
          supabase db push --db-url "$SUPABASE_DB_URL_VERIFY"
          echo "[MIGRATE][VERIFY] History aligned."

      - name: supabase db push (PROD)
        run: |
          set -euo pipefail
          echo "[MIGRATE][PROD] Running supabase db push on PROD to align migration history..."
          supabase db push --db-url "$SUPABASE_DB_URL_PROD"
          echo "[MIGRATE][PROD] History aligned."
